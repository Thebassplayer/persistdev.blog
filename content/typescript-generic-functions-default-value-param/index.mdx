---
title: "Understanding TypeScript Generics: Passing Type Arguments to Functions"
description: "Learn how to work with generics in TypeScript by passing type arguments to functions, enhancing flexibility and type safety in your code."
image: "../../public/posts/typescript-generic-functions-default-value-param.jpg"
publishedAt: "2025-01-31"
updatedAt: "2025-01-31"
author: "Roy Lopez"
isPublished: true
tags:
  - typescript
  - generics
  - programming
---

TypeScript generics are a key feature that allows developers to write reusable and flexible code with type safety. A common use case for generics is passing type arguments to functions. In this article, we'll explore how to achieve this in TypeScript and use practical examples to illustrate the concept.

---

## **The Problem: Functions Without Type Arguments**

Suppose you want to create a utility function that generates a new array. Initially, the function doesn't support specifying the type of the array elements:

```typescript
export const createArray = () => {
  return [];
};
```

If you try to create a typed array using this function, you won't be able to specify the type of the elements, leading to a lack of type safety:

```typescript
const numbers = createArray(); // Type: any[]
numbers.push(42); // ✅ Works
numbers.push("hello"); // ✅ Works (but this may not be desirable)
```

This issue arises because the function does not have a way to accept type arguments. To address this, we can leverage TypeScript generics.

---

**Solution: Adding a Generic Type Argument** By adding a generic type parameter `<T>` to the function, we can allow it to accept a type argument:

```typescript
export const createArray = <T>() => {
  return [] as T[];
};
```

Now, the function can return an array of a specific type:

```typescript
const numbers = createArray<number>();
numbers.push(42); // ✅ Works
numbers.push("hello"); // ❌ Error: Argument of type 'string' is not assignable to parameter of type 'number'.
```

With this modification, TypeScript ensures that only values of the specified type can be added to the array.

---

**Inferring the Type Argument**
Manually specifying the type argument is useful, but it can sometimes be tedious. A more flexible approach is to infer the type argument based on the initial value provided to the function.
Here’s how we can update the `createArray` function to accept an optional `initialValue`:

```typescript
export const createArray = <T>(initialValue?: T) => {
  const newArray = initialValue !== undefined ? [initialValue] : [];
  return newArray as T[];
};
```

With this change, you no longer need to explicitly provide the type argument if you pass an initial value:

```typescript
const strings = createArray("hello"); // Type: string[]
strings.push("world"); // ✅ Works
strings.push(42); // ❌ Error: Argument of type 'number' is not assignable to parameter of type 'string'.

const numbers = createArray(100); // Type: number[]
numbers.push(200); // ✅ Works
```

If no initial value is provided, you can still specify the type explicitly:

```typescript
const booleanArray = createArray<boolean>(); // Type: boolean[]
booleanArray.push(true); // ✅ Works
```

---

TypeScript's Default Type Argument: `unknown`\*\* If no type argument is specified and no `initialValue` is provided, TypeScript defaults to `unknown` as the type. This is worth keeping in mind when using generics, as `unknown` allows any value to be assigned:

```typescript
const mixedArray = createArray(); // Type: unknown[]
mixedArray.push(42); // ✅ Works
mixedArray.push("hello"); // ✅ Works
```

To enforce stricter type safety, always provide a type argument or use an `initialValue` to allow TypeScript to infer the type.

---

**Using Generics with Built-in Types** The concept of generics is not limited to custom functions. Many built-in types in TypeScript, such as `Array`, `Set`, and `Map`, also leverage generics to ensure type safety.Example: Using `Set` with GenericsWhen creating a new `Set`, you can specify a type argument to enforce type safety:

```typescript
const uniqueStrings = new Set<string>();
uniqueStrings.add("hello"); // ✅ Works
uniqueStrings.add(123); // ❌ Error: Argument of type 'number' is not assignable to parameter of type 'string'.
```

Without a type argument, the `Set` defaults to `unknown`:

```typescript
const genericSet = new Set(); // Type: Set<unknown>
genericSet.add(42); // ✅ Works
genericSet.add("hello"); // ✅ Works
```

By using generics, you can ensure the `Set` only contains elements of a specific type, reducing the likelihood of runtime errors.

---

**Key Takeaways**

1. **Generics Add Flexibility and Safety**
   Adding generics to your functions allows you to write reusable code that works with a variety of types, all while maintaining strict type safety.

2. **Type Inference Simplifies Usage**
   By inferring the type argument from the function's inputs, you can reduce boilerplate and make your code easier to use.

3. **Default Type is `unknown`**
   When no type argument is provided, TypeScript defaults to `unknown`, which allows any type but reduces type safety.

4. **Built-in Types Benefit from Generics**
   Built-in types like `Array`, `Set`, and `Map` use generics to enforce type safety, making them more versatile and reliable.

---

By mastering TypeScript generics and learning how to pass type arguments to functions, you can create robust and reusable code. Whether you're working with arrays, sets, or other data structures, generics give you the tools to make your applications safer and easier to maintain.
